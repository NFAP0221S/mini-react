# React 컴포넌트 생명주기와 DOM 업데이트 과정

## 1. React 컴포넌트 생명주기 (Lifecycle)

React 컴포넌트는 마운트(Mount), 업데이트(Update), 언마운트(Unmount)라는 세 가지 주요 단계로 나뉘는 생명주기를 가지고 있습니다. 이 생명주기 동안 다양한 생명주기 메서드가 호출되며, 이를 통해 컴포넌트가 생성, 업데이트, 제거될 때 특정 작업을 수행할 수 있습니다.

### 1.1. 마운트 (Mount)

마운트 단계는 컴포넌트가 처음으로 DOM에 삽입될 때 발생합니다. 이 단계에서 호출되는 주요 메서드는 다음과 같습니다:

- **constructor(props)**: 컴포넌트가 처음 생성될 때 호출됩니다. 초기 state를 설정하거나, 메서드를 바인딩할 때 사용됩니다.
- **static getDerivedStateFromProps(props, state)**: props에 따라 state를 업데이트해야 할 때 사용됩니다. 컴포넌트가 마운트되기 직전에 호출됩니다.
- **render()**: JSX를 반환하여 렌더링될 UI를 정의합니다. 필수적으로 구현해야 하는 메서드입니다.
- **componentDidMount()**: 컴포넌트가 처음 렌더링된 후, 즉 DOM에 삽입된 직후 호출됩니다. 이 시점에서 DOM 노드를 조작하거나, 네트워크 요청을 시작하는 등의 작업을 할 수 있습니다.

### 1.2. 업데이트 (Update)

업데이트 단계는 컴포넌트의 props, state, 또는 context가 변경되어 다시 렌더링될 때 발생합니다. 이 단계에서 호출되는 주요 메서드는 다음과 같습니다:

- **static getDerivedStateFromProps(props, state)**: props 변화에 따라 state를 업데이트해야 할 때 사용됩니다. 업데이트 전에도 호출됩니다.
- **shouldComponentUpdate(nextProps, nextState)**: 리렌더링을 할지 말지 결정하는 메서드입니다. 성능 최적화를 위해 사용되며, `true`를 반환하면 리렌더링을 수행하고, `false`를 반환하면 리렌더링을 건너뜁니다.
- **render()**: 마운트 단계와 동일하게, JSX를 반환하여 UI를 정의합니다.
- **getSnapshotBeforeUpdate(prevProps, prevState)**: DOM이 업데이트되기 직전에 호출되며, 현재의 DOM 상태를 스냅샷으로 캡처하여 업데이트 후에 사용할 수 있습니다.
- **componentDidUpdate(prevProps, prevState, snapshot)**: 컴포넌트가 업데이트된 후 호출됩니다. 이 메서드에서는 이전 props와 state를 사용할 수 있으며, DOM이 업데이트된 이후에 필요한 작업을 수행할 수 있습니다.

### 1.3. 언마운트 (Unmount)

언마운트 단계는 컴포넌트가 DOM에서 제거될 때 발생합니다. 이 단계에서 호출되는 주요 메서드는 다음과 같습니다:

- **componentWillUnmount()**: 컴포넌트가 DOM에서 제거되기 직전에 호출됩니다. 타이머를 정리하거나, 네트워크 요청을 취소하거나, 이벤트 리스너를 제거하는 등의 작업을 수행할 수 있습니다.

## 2. DOM 업데이트 과정

React는 컴포넌트의 상태가 변경되었을 때 전체 UI를 다시 렌더링하지 않고, 변경된 부분만 실제 DOM에 반영하는 방식으로 효율적으로 동작합니다. 이를 위해 Virtual DOM을 사용하며, 업데이트 과정은 다음과 같은 단계로 이루어집니다:

### 2.1. 렌더 단계 (Render Phase)

렌더 단계에서는 다음과 같은 작업이 이루어집니다:

- **Virtual DOM 생성**: 컴포넌트의 `render` 메서드가 호출되면, 새로운 Virtual DOM 트리가 생성됩니다. 이 Virtual DOM은 JavaScript 객체로 구성된 트리 구조이며, 컴포넌트의 상태와 props에 따라 현재의 UI를 나타냅니다.
- **Diffing**: React는 이전 Virtual DOM과 새로 생성된 Virtual DOM을 비교합니다. 이 과정은 "Diffing Algorithm"이라고 불리며, 두 트리 간의 최소 차이를 찾는 과정입니다. 이 단계에서 변경된 부분만을 찾아내고, 이를 효율적으로 업데이트할 수 있는 계획을 세웁니다.
- **Effect List 생성**: 변경된 부분에 대한 업데이트 계획이 세워지면, 이를 "Effect List"라는 형태로 저장합니다. 이 리스트에는 DOM에 반영해야 할 모든 변경 사항이 포함됩니다.

### 2.2. 커밋 단계 (Commit Phase)

커밋 단계에서는 다음과 같은 작업이 이루어집니다:

- **DOM 업데이트**: 렌더 단계에서 생성된 Effect List를 기반으로, 실제 DOM을 업데이트합니다. 이 과정에서는 변경된 부분만을 실제 DOM에 반영하여 성능을 최적화합니다. 새로운 노드가 추가되거나, 기존 노드가 업데이트되거나, 제거됩니다.
- **생명주기 메서드 호출**: DOM이 업데이트된 후, `componentDidUpdate`와 같은 생명주기 메서드가 호출됩니다. 이를 통해 업데이트 이후에 추가적인 작업을 수행할 수 있습니다.

## 3. React에서의 DOM 업데이트 최적화

React는 기본적으로 Virtual DOM과 Diffing 알고리즘을 사용하여 DOM 업데이트를 최적화하지만, 개발자가 추가적인 최적화를 할 수도 있습니다:

- **shouldComponentUpdate 메서드**: 이 메서드를 통해 특정 상황에서 리렌더링을 방지할 수 있습니다. 예를 들어, 상태나 props가 변경되지 않았다면 굳이 리렌더링할 필요가 없으므로 `false`를 반환하여 리렌더링을 건너뛸 수 있습니다.
- **React.memo**: 함수 컴포넌트에서 props가 변경되지 않는다면, `React.memo`를 사용하여 리렌더링을 방지할 수 있습니다. 이는 `shouldComponentUpdate`의 함수 컴포넌트 버전과 유사합니다.
- **Key를 사용한 리스트 렌더링**: 리스트를 렌더링할 때 고유한 `key`를 사용하면, React가 각 항목을 고유하게 식별하여 최소한의 업데이트만을 수행할 수 있습니다.

## 4. Fiber 아키텍처

React 16 이후 도입된 Fiber 아키텍처는 React의 렌더링 과정을 더 세밀하게 관리하고 최적화할 수 있게 합니다. 주요 특징은 다음과 같습니다:

- **비동기적 렌더링**: Fiber는 작업을 여러 작은 단위로 나누어 브라우저가 유휴 상태일 때마다 조금씩 작업을 수행할 수 있습니다. 이를 통해 복잡한 작업을 수행하더라도 UI의 응답성을 유지할 수 있습니다.
- **우선순위 기반 업데이트**: Fiber는 각 작업에 우선순위를 부여하여 중요한 작업이 먼저 수행되도록 합니다. 예를 들어, 사용자 입력은 높은 우선순위를 가지므로, 렌더링 작업보다 우선적으로 처리됩니다.
- **작업 중단 및 재개**: Fiber는 작업을 중단하고 나중에 다시 재개할 수 있습니다. 이를 통해 긴 렌더링 작업도 사용자 인터페이스의 응답성을 유지하면서 처리할 수 있습니다.

## 결론

React의 생명주기와 DOM 업데이트 과정은 매우 효율적으로 설계되어 있으며, 이를 이해하고 활용함으로써 성능이 뛰어난 애플리케이션을 개발할 수 있습니다. Virtual DOM과 Diffing, Fiber 아키텍처는 React의 성능을 높이는 핵심 요소입니다. 이 과정을 이해하면 React 컴포넌트를 최적화하는 방법을 더 잘 이해할 수 있으며, 실제 애플리케이션에서 React의 동작 방식을 최대한 활용할 수 있습니다.